Measure.swift
	public static func rangeFromMeasures(
        measures: [Measure],
        startingAtIndex index: Int,
        constrainedByMaximumTotalDuration maximumDuration: Duration
    ) -> [Measure]
DurationNode.swift
	public var id: String?
	public override var description: String { get { return getDescription() } }
	public var offsetDuration: Duration = DurationZero
	public var durationSpan: DurationSpan { get { return getDurationSpan() } }
	public var components: [Component] = []
	public var isRest: Bool { get { return components.count == 0 && isLeaf } }
	public var iIDsByPID : [String : [String]] { get { return getIIDsByPID() } }
	public func distanceFromDurationNode(durationNode: DurationNode) -> Duration?
	public func distanceFromDuration(duration: Duration) -> Duration?
	public class func rangeFromDurationNodes(durationNodes: [DurationNode],
        inDurationSpan durationSpan: DurationSpan
    )
	public class func random() -> DurationNode
	public class func getMaximumSubdivisionOfSequence(sequence: [DurationNode]) -> Subdivision?
	public class func getMinimumSubdivisionOfSequence(sequence: [DurationNode]) -> Subdivision?
	public class func matchDurationsOfSequence(sequence: [DurationNode])
	public class func levelDurationsOfSequence(sequence: [DurationNode])
	public class func reduceDurationsOfSequence(sequence: [DurationNode])
	public class func allSubdivisionsOfSequenceAreEquivalent(sequence: [DurationNode]) -> Bool
	public class func getRelativeDurationsOfSequence(sequence: [DurationNode]) -> [Int]
	public func addRandomComponentsToLeavesWithPID(pID: String, andIID iID: String)
	public func addChildWithBeats(beats: Int)
	public func addComponent(component: Component)
	public func clearComponents()
	public func setOffsetDurationOfChildren()
	public func matchDurationsOfTree()
	public func scaleDurationsOfTree(scale scale: Float) -> DurationNode
	public func matchDurationToChildren_nonDestructive()
	public override func getDescription() -> String
ScoreInfo.swift
	public struct ScoreInfo
	public var iIDsAndInstrumentTypesByPID: [[String: [(String, InstrumentType)]]]
	public var measures: [Measure]
	public var tempoMarkings: [TempoMarking]
	public var durationNodes: [DurationNode]
	public var rehearsalMarkings: [RehearsalMarking]
	public init(
        iIDsAndInstrumentTypesByPID: [[String: [(String,InstrumentType)]]],
        measures: [Measure],
        tempoMarkings: [TempoMarking],
        durationNodes: [DurationNode],
        rehearsalMarkings: [RehearsalMarking]
    )
PitchFine.swift
	public enum PitchFine: String, CustomStringConvertible
	case None = ""
	case Up = "Up"
	case Down = "Down"
	public var description: String { get { return self.rawValue } }
Component.swift
	public enum ComponentProperty
	case SlurStart
	case SlurStop
	case Dynamic(marking: String)
	case DMLigatureStart(type: Float)
	case DMLigatureStop
	case Articulation(markings: [String])
	case Pitch(pitches: [Float])
	case Rest
	case ExtensionStart
	case ExtensionStop
	case Node(value: Float)
	case EdgeStart(hasDashes: Bool)
	case EdgeStop
	case Wave
	case TempoMarking(value: Int, subdivisionValue: Int)
	case Label(value: String)
	case StringArtificialHarmonic(pitch: Float)
	case StringNumber(romanNumeral: String)
	case StringBowDirection(direction: String)
	case GlissandoStart
	case GlissandoStop
	public protocol Component
	var pID: String { get set }
	var iID: String { get set }
	var property: ComponentProperty { get set }
	var isGraphBearing: Bool { get set }
	var name: String { get set }
	public struct ComponentPitch: Component
	public var name = "pitch"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = true
	public init(pID: String, iID: String, pitches: [Float])
	public struct ComponentGlissandoStart: Component
	public var name = "glissando"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(pID: String, iID: String)
	public struct ComponentGlissandoStop: Component
	public var name = "glissando"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(pID: String, iID: String)
	public struct ComponentArticulation: Component
	public var name = "articulation"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(pID: String, iID: String, markings: [String])
	public struct ComponentDynamic: Component
	public var name = "dynamic"
	public var id: String
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(id: String, pID: String, iID: String, marking: String)
	public protocol ComponentDMLigature: Component
	var id: String { get set }
	public struct ComponentDMLigatureStart: ComponentDMLigature
	public var name = "dynamic"
	public var id: String
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(id: String, pID: String, iID: String, type: Float)
	public struct ComponentDMLigatureStop: ComponentDMLigature
	public var name = "dynamic"
	public var id: String
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(id: String, pID: String, iID: String)
	public protocol ComponentSlur: Component
	var id: String { get set }
	public struct ComponentSlurStart: ComponentSlur
	public var name = "slur"
	public var id: String
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(id: String, pID: String, iID: String)
	public struct ComponentSlurStop: ComponentSlur
	public var name = "slur"
	public var id: String
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(id: String, pID: String, iID: String)
	public struct ComponentRest: Component
	public var name = "rest"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = true
	public init(pID: String, iID: String)
	public struct ComponentExtensionStart: Component
	public var name = "extension"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(pID: String, iID: String)
	public struct ComponentExtensionStop: Component
	public var name = "extension"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(pID: String, iID: String)
	public struct ComponentNode: Component
	public var name = "node"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = true
	public init(pID: String, iID: String, value: Float)
	public struct ComponentEdgeStart: Component
	public var name = "edge_start"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = true
	public init(pID: String, iID: String, hasDashes: Bool)
	public struct ComponentEdgeStop: Component
	public var name = "edge_stop"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = true
	public init(pID: String, iID: String)
	public struct ComponentWave: Component
	public var name = "wave"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = true
	public init(pID: String, iID: String)
	public struct ComponentLabel: Component
	public var name = "label"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(pID: String, iID: String, value: String)
	public struct ComponentStringArtificialHarmonic: Component
	public var name = "string_artificial_harmonic"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = true
	public init(pID: String, iID: String, pitch: Float)
	public struct ComponentStringNumber: Component
	public var name = "string_string_number"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(pID: String, iID: String, romanNumeral: String)
	public struct ComponentStringBowDirection: Component
	public var name = "string_string_bow_direction"
	public var pID: String
	public var iID: String
	public var property: ComponentProperty
	public var isGraphBearing: Bool = false
	public init(pID: String, iID: String, bowDirection: String)
PitchPolyphony.swift
	public class PitchPolyphony
	public var verticalities: [PitchVerticality] = []
	public init() {}
	public init(verticalities: [PitchVerticality])
	public func addVerticality(verticality: PitchVerticality) -> PitchPolyphony
TempoFunction.swift
	public class TempoFunction
DurationNodeDyad.swift
	public class DurationNodeDyad
	public var durationNode0: DurationNode
	public var durationNode1: DurationNode
	public var durationSpan: DurationSpan
	public var relationship: DurationNodeDyadRelationship { get { return getRelationship() } }
	public var hasMatchingPIDs: Bool { get { return getHasMatchingPIDs() } }
	public init(durationNode0: DurationNode, durationNode1: DurationNode)
	public enum DurationNodeDyadRelationship
	case None, Adjacent, Overlapping
	case None, Adjacent, Overlapping
	case None, Adjacent, Overlapping
PitchSpeller.swift
	public class func spellDyad(dyad: PitchDyad)
	public class func spellVerticality(verticality: [Pitch])
PitchDyadSpeller.swift
	public var prevailingFine: Float?
	public var stepPreserving: [PitchSpellingDyad]
	public var fineMatching: [PitchSpellingDyad]
	public var coarseMatching: [PitchSpellingDyad]
	public var desiredFine: Float?
	public var desiredCoarseDirection: Float?
	public var desiredCoarseResolution: Float?
	public var coarseDirectionMatching: [PitchSpellingDyad]
	public var coarseResolutionMatching: [PitchSpellingDyad]
	public var bothPitchesHaveBeenSpelled: Bool
	public var onePitchHasBeenSpelled: Bool
	public var neitherPitchHasBeenSpelled: Bool
	public var canBeSpelledObjectively: Bool
	public init(dyad: PitchDyad)
	public func spellWithDesiredFine(fine: Float)
	public func spellWithDesiredCoarseDirection(coarseDirection: Float)
	public func spellWithDesiredCoarseResolution(coarseResolution: Float)
	public func spell()
	public func oneSpelled()
	public func oneSpelledHalfTone(spelled spelled: Pitch, unspelled: Pitch)
	public func oneSpelledQuarterTone(spelled spelled: Pitch, unspelled: Pitch)
	public func oneSpelledEighthTone(spelled spelled: Pitch, unspelled: Pitch)
	public func neitherSpelled()
	public func spellPitchesObjectivelyIfPossible()
	public func getCoarseMatching() -> [PitchSpellingDyad]
	public func getCoarseResolutionMatching() -> [PitchSpellingDyad]
	public func getCoarseDirectionMatching() -> [PitchSpellingDyad]
	public func getFineMatching() -> [PitchSpellingDyad]
	public func getStepPreserving() -> [PitchSpellingDyad]
Duration.swift
	public var floatValue: Float? { get { return getFloatValue() } }
	public static func random() -> Duration
	public init(floatValue: Float)
	public mutating func respellAccordingToBeats(amountBeats: Int)
	public mutating func respellAccordingToSubdivisionValue(subdivisionValue: Int)
DurationSpan.swift
	public var description: String { get { return getDescription() } }
	public var startDuration: Duration = DurationZero
	public var stopDuration: Duration = DurationZero
	public var duration: Duration = DurationZero
	public init() { }
	public func makeDurationSpanWithDurationNodes(durationNodes: [DurationNode]) -> DurationSpan
	public enum DurationSpanRelationship
	case None, Adjacent, Overlapping
	case None, Adjacent, Overlapping
	case None, Adjacent, Overlapping
	public func isInDurationSpan(durationSpan: DurationSpan) -> Bool
PitchVerticalitySpeller.swift
	public var verticality: PitchVerticality
	public var prevailingFine: Float?
	public var allPitchesHaveBeenSpelled: Bool { get { return getAllPitchesHaveBeenSpelled() } }
	public var allFineValuesMatch: Bool { get { return getAllFineValuesMatch() } }
	public init(verticality: PitchVerticality)
	public func spell()
InstrumentType.swift
	public class InstrumentFamily
	public static func has(instrumentType: InstrumentType) -> Bool
	public static func containsInstrumentType(instrumentType: InstrumentType) -> Bool
	public class Strings: InstrumentFamily
	public static let Violin: InstrumentType = .Violin
	public static let Viola: InstrumentType = .Viola
	public static let Violoncello: InstrumentType = .Violoncello
	public static let Guitar: InstrumentType = .Guitar
	public class Woodwinds: InstrumentFamily
	public class Flutes: InstrumentFamily
	public static let Piccolo: InstrumentType = .Flute_Piccolo
	public static let C: InstrumentType = .Flute_C
	public static let Alto: InstrumentType = .Flute_Alto
	public static let Bass: InstrumentType = .Flute_Bass
	public static let Contrabass: InstrumentType = .Flute_Contrabass
	public class Clarinets: InstrumentFamily
	public static let Bflat: InstrumentType = .Clarinet_Bflat
	public static let A: InstrumentType = .Clarinet_A
	public static let Bass: InstrumentType = .Clarinet_Bass
	public static let Contrabass: InstrumentType = .Clarinet_Contrabass
	public class DoubleReeds: InstrumentFamily
	public static let Oboe: InstrumentType = .Oboe
	public static let Oboe_dArmore: InstrumentType = .Oboe_dAmore
	public static let English_Horn: InstrumentType = .English_Horn
	public static let Bassoon: InstrumentType = .Bassoon
	public class Saxophones: InstrumentFamily
	public static let Sopranino: InstrumentType = .Saxophone_Sopranino
	public static let Soprano: InstrumentType = .Saxophone_Soprano
	public static let Alto: InstrumentType = .Saxophone_Alto
	public static let Baritone: InstrumentType = .Saxophone_Baritone
	public static let Bass: InstrumentType = .Saxophone_Bass
	public static let Contrabass: InstrumentType = .Saxophone_Contrabass
	public class Brass: InstrumentFamily
	public class Trumpets: InstrumentFamily
	public static let Bflat: InstrumentType = .Trumpet_Bflat
	public static let C: InstrumentType = .Trumpet_C
	public let InstrumentFamilies: [InstrumentFamily.Type] = InstrumentFamily.subfamilies
	public enum InstrumentType: String
	case Violin
	case Viola
	case Violoncello
	case Guitar
	case Flute_Piccolo
	case Flute_C
	case Flute_Alto
	case Flute_Bass
	case Flute_Contrabass
	case Clarinet_Bflat
	case Clarinet_A
	case Clarinet_Bass
	case Clarinet_Contrabass
	case Oboe
	case Oboe_dAmore
	case English_Horn
	case Bassoon
	case Saxophone_Sopranino
	case Saxophone_Soprano
	case Saxophone_Alto
	case Saxophone_Tenor
	case Saxophone_Baritone
	case Saxophone_Bass
	case Saxophone_Contrabass
	case Trumpet_Bflat
	case Trumpet_C
	case Trombone_Bflat
	case Trombone_F
	case Horn // different keys
	case Euphonium // different keys
	case Tuba
	case Percussion_Skin // enum
	case Percussion_Metal // enum
	case Percussion_Wood // enum
	case Keyboard_Piano
	case ContinuousController
	case BinarySwitch
	case MultiStateSwitch
	case Trigger
	case Waveform
	public func isInInstrumentFamily(instrumentFamily: InstrumentFamily.Type) -> Bool
	public var preferredClefsAndTransposition: [(String, Int, Bool)]
PitchDyad.swift
	public var description: String { get { return getDescription() } }
	public var interval: PitchInterval { get
	public func getDescription() -> String
Pitch.swift
	public var octave: Int { get { return getOctave() } }
	public class func random(amount: Int, min: Float, max: Float, resolution: Float) -> [Pitch]
	public static func middleC() -> Pitch
	public func clearPitchSpelling()
	public func ==(lhs: Pitch, rhs: Pitch) -> Bool
	public func <(lhs: Pitch, rhs: Pitch) -> Bool
	public func >(lhs: Pitch, rhs: Pitch) -> Bool
	public func <=(lhs: Pitch, rhs: Pitch) -> Bool
	public func >=(lhs: Pitch, rhs: Pitch) -> Bool
PitchSpellingDyad.swift
	public func ==(lhs: PitchSpellingDyad, rhs: PitchSpellingDyad) -> Bool
PitchLetterName.swift
	public enum PitchLetterName: Float/*, CustomStringConvertible*/
	case C = 0.0
	case D = 0.5
	case E = 1.0
	case F = 1.5
	case G = 2.0
	case A = 2.5
	case B = 3.0
	public static func pitchLetterNameWithString(string string: String) -> PitchLetterName?
	public var staffSpaces: Float { get { return rawValue } }
	public var description: String
	public func ==(lhs: PitchLetterName, rhs: PitchLetterName) -> Bool
	public func >(lhs: PitchLetterName, rhs: PitchLetterName) -> Bool
	public func <(lhs: PitchLetterName, rhs: PitchLetterName) -> Bool
	public func >=(lhs: PitchLetterName, rhs: PitchLetterName) -> Bool
	public func <=(lhs: PitchLetterName, rhs: PitchLetterName) -> Bool
PitchVerticality.swift
	public class PitchVerticality: CustomStringConvertible
	public var description: String { get { return "\(pitches)" } }
	public var pitches: [Pitch]
	public var dyads: [PitchDyad]? { get { return getDyads() } }
	public var allPitchesHaveBeenSpelled: Bool { get { return getAllPitchesHaveBeenSpelled() } }
	public init()
	public init(pitches: [Pitch])
	public init(verticality0: PitchVerticality, verticality1: PitchVerticality)
	public func addPitch(pitch: Pitch) -> PitchVerticality
	public func addPitches(pitches: [Pitch]) -> PitchVerticality
	public func removeDuplicates()
	public func clearPitchSpellings()
Tempo.swift
	public class Tempo
PitchSpelling.swift
	public var pitch: Pitch
	public var letterName: PitchLetterName
	public var octave: Int
	public func getDescription() -> String
	public func ==(lhs: PitchSpelling, rhs: PitchSpelling) -> Bool
	public func <(lhs: PitchSpelling, rhs: PitchSpelling) -> Bool
	public func >(lhs: PitchSpelling, rhs: PitchSpelling) -> Bool
	public func >=(lhs: PitchSpelling, rhs: PitchSpelling) -> Bool
	public func <=(lhs: PitchSpelling, rhs: PitchSpelling) -> Bool
PitchCoarse.swift
	public enum PitchCoarse: String, CustomStringConvertible
	case Natural = "Natural"
	case Sharp = "Sharp"
	case QuarterSharp = "QuarterSharp"
	case Flat = "Flat"
	case QuarterFlat = "QuarterFlat"
	public var description: String { get { return self.rawValue } }
